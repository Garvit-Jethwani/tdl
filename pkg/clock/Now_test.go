// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test-tdl using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=Now_764eeb0542
ROOST_METHOD_SIG_HASH=Now_9a6e33c9c4

Scenario 1: Positive Time Offset

Details:
Description: This test is meant to check that the function correctly returns the time after the specific positive duration.

Execution:
Arrange: Set up networkClock struct with positive offset of 1 hour.
Act: Invoke the Now() function.
Assert: Check whether the returned time equals the current time plus 1-hour offset.

Validation: 
The assert will compare the returned time and the current time after 1-hour offset. If there is a correct time offset, it means the function runs correctly. This scenario is frequently encountered in normal operations.

Scenario 2: Negative Time Offset

Details:
Description: This test is meant to check that the function correctly returns the time before the specific negative duration. 

Execution:
Arrange: Set up networkClock struct with negative offset of 1 hour.
Act: Invoke the Now() function.
Assert: Check whether the returned time equals the current time minus 1-hour offset.

Validation: 
The assert will compare the returned time and the current time after the 1-hour offset. If there is a correct time offset, it means the function works correctly. This scenario is crucial for covering areas where the offset may pull the time backwards.

Scenario 3: Zero Time Offset 

Details:
Description: This test checks whether the Now() function returns the correct current time when the offset is zero.

Execution:
Arrange: Set up networkClock struct with zero offset.
Act: Invoke the Now() function.
Assert: Check whether the returned time equals the current time.

Validation:
The assert will compare the returned time and the current time. If both times match, it means the function works correctly. This test is important in applications where the system's timezone matches the network's timezone.

Scenario 4: Large Positive Time Offset 

Details:
Description: This test is designed to check for outliers in offsets and to make sure the function correctly handles large positive offsets.

Execution:
Arrange: Set up networkClock struct with an offset of 1000 hours.
Act: Invoke the Now() function.
Assert: Check whether the returned time equals the current time plus the 1000-hour offset.

Validation: 
The comparison in this assertion will validate if the function handles large offsets correctly. It's important to handle such cases correctly, as ignoring them could lead to incorrect timestamps that could potentially miscue operations sensitive to time.

Scenario 5: Large Negative Time Offset 

Details:
Description: This test is designed to check for outliers in offsets and to make sure the function correctly handles large negative offsets.

Execution:
Arrange: Set up networkClock struct with an offset of -1000 hours.
Act: Invoke the Now() function.
Assert: Check whether the returned time equals the current time minus the 1000-hour offset.

Validation:
This assertion will confirm if the function properly executes even with large negative offsets. The ability to handle such extreme cases gracefully is important to ensure accurate and reliable operations throughout the application.
*/

// ********RoostGPT********
package clock

import (
	"testing"
	"time"
)

// TestNow checks five scenarios given in the instructions
func TestNow(t *testing.T) {
	tests := []struct {
		name string
		offset time.Duration 
		want time.Duration 
	}{
		{"Positive Time Offset", time.Hour, time.Hour},
		{"Negative Time Offset", -time.Hour, -time.Hour},
		{"Zero Time Offset", 0, 0},
		{"Large Positive Time Offset", time.Hour * 1000, time.Hour * 1000},
		{"Large Negative Time Offset", -time.Hour * 1000, -time.Hour * 1000},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			nc := networkClock{
				offset: tt.offset,
			}

			got := nc.Now()

			diff := got.Sub(time.Now())

			if diff != tt.want {
				t.Errorf("Now() = %v, want %v", diff, tt.want)
			} 
		})
	}
}
