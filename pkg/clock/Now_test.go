// ********RoostGPT********
/*
Test generated by RoostGPT for test go-test-tdl using AI Type Azure Open AI and AI Model roostgpt-4-32k

ROOST_METHOD_HASH=Now_764eeb0542
ROOST_METHOD_SIG_HASH=Now_9a6e33c9c4

Scenario 1: Correct Offset Applied

Details:
    Description: This test is meant to verify that the offset is correctly incorporated when the Now function is called. The time.Now() function returns the current system time. The Now function adds the offset to this time.

Execution:
    Arrange: Initialize the networkClock struct with a specific offset (e.g., 5 hours).
    Act: Call the Now function.
    Assert: Check if the returned time is the current system time (using time.Now()) plus the offset.

Validation:
    The purpose of having an offset in the first place is to potentially adjust the system time according to specific requirements. Therefore, it's crucial to ensure that the offset is applied correctly, as this determines the accuracy of the returned time. The assertion checks if the returned time and system time plus offset are equal, considering some small margin of error due to the execution time.

Scenario 2: No Offset Applied

Details:
    Description: This test is to ensure that without an offset, the Now function returns the equivalent of calling time.Now() (i.e., the system's current time).

Execution:
    Arrange: Initialize the networkClock struct with an offset of 0.
    Act: Call the Now function.
    Assert: Check if the returned time is equal to the current system time by comparing it with time.Now().

Validation:
    Even when no offset is applied, the Now function should not add any errors and it should give out the accurate system time. This test ensures that any unnecessary or unknowing shifts are not happening when offset is zero.

Scenario 3: Negative Offset

Details:
    Description: This test is to verify that the Now function correctly handles a negative offset.

Execution:
    Arrange: Initialize the networkClock struct with a specific negative offset (e.g., -3 hours).
    Act: Call the Now function.
    Assert: Check if the returned time is the current system time minus the absolute value of the offset.

Validation:
    This test ensures that the Now function correctly calculates the date and time even when offset is negative, effectively going back in time. The negative offset can be useful in cases where the system operates in a time zone ahead of the network time.

Scenario 4: Large Offset Value

Details:
    Description: This test checks if the Now function correctly handles large offsets, such as those that would adjust the current time by a number of days.

Execution:
    Arrange: Initialize the networkClock struct with a large offset (e.g., 120 hours or 5 days).
    Act: Call the Now function.
    Assert: Check if the returned time is the current system time plus the offset.

Validation:
    Although it is uncommon to use such large offsets, it is still important to verify that the Now function can handle them without errors. In case of special business requirements where large offsets are needed, this test ensures the functionality of the function.
*/

// ********RoostGPT********
package clock_test

import (
	"testing"
	"time"
	"github.com/google/go-cmp/cmp"
	"github.com/gotd/td/clock"
)

// Please note that NetworkClock should be exported type, as it's being accessed from other packages (if not, it should be defined in the test package).
type NetworkClock struct{ offset time.Duration }  

func (n *NetworkClock) Now() time.Time {
    return time.Now().Add(n.offset)
}

func TestNow(t *testing.T) {
	tests := []struct {
		name   string
		offset time.Duration
	}{
		{"Correct Offset Applied", 5 * time.Hour},
		{"No Offset Applied", 0},
		{"Negative Offset", -3 * time.Hour},
		{"Large Offset Value", 120 * time.Hour},
	}

	for _, tc := range tests {
		t.Run(tc.name, func(t *testing.T) {
			// Arrange
			n := NetworkClock{offset: tc.offset}

			// Act
			result := n.Now()

			// Assert
			expected := time.Now().Add(tc.offset)

			// Use the Equal function to compare the times. Truncate both expected time and result time to second level precision to avoid failure due to minor deviations.
			if !cmp.Equal(expected.Truncate(time.Second), result.Truncate(time.Second)) {
				t.Errorf("Time mismatch, expected: %v, got: %v", expected.Truncate(time.Second), result.Truncate(time.Second))
			}
		})
	}
}
