// ********RoostGPT********
/*
Test generated by RoostGPT for test golang-sample-programs using AI Type Open AI and AI Model gpt-4

1. Scenario: Testing the Repeat function with a non-empty string and a positive integer. The function should return the string repeated the specified number of times.

2. Scenario: Testing the Repeat function with an empty string and a positive integer. The function should return an empty string regardless of the integer value.

3. Scenario: Testing the Repeat function with a non-empty string and zero as the repeating integer. The function should return an empty string.

4. Scenario: Testing the Repeat function with a non-empty string and a negative integer. The function should return an error or an empty string, based on the GoLang default behavior.

5. Scenario: Testing the Repeat function with special characters in the string and a positive integer. The function should return the string with special characters repeated the specified number of times.

6. Scenario: Testing the Repeat function with a string containing whitespace and a positive integer. The function should return the string including whitespace repeated the specified number of times.

7. Scenario: Testing the Repeat function with a very long string and a large integer. This is to test the performance and memory handling of the function.

8. Scenario: Testing the Repeat function with a non-English string (like Chinese, Arabic, etc.) and a positive integer. The function should correctly repeat the non-English string.

9. Scenario: Testing the Repeat function with a string that includes newline characters and a positive integer. The function should repeat the string along with the newline characters.

10. Scenario: Testing the Repeat function with a string that includes escape sequences and a positive integer. The function should repeat the string along with the escape sequences.
*/

// ********RoostGPT********
package tplfunc

import (
	"strings"
	"testing"
	"text/template"
)

func TestRepeat_b70e63dbe6(t *testing.T) {
	testCases := []struct {
		name     string
		input    string
		repeat   int
		expected string
	}{
		{
			name:     "Non-empty string, positive integer",
			input:    "abc",
			repeat:   2,
			expected: "abcabc",
		},
		{
			name:     "Empty string, positive integer",
			input:    "",
			repeat:   5,
			expected: "",
		},
		{
			name:     "Non-empty string, zero repeat",
			input:    "abc",
			repeat:   0,
			expected: "",
		},
		{
			name:     "String with special characters, positive integer",
			input:    "!@#$",
			repeat:   3,
			expected: "!@#$!@#$!@#$",
		},
		{
			name:     "String with whitespace, positive integer",
			input:    "abc def",
			repeat:   2,
			expected: "abc defabc def",
		},
		{
			name:     "Very long string, large integer",
			input:    strings.Repeat("a", 10000),
			repeat:   10000,
			expected: strings.Repeat(strings.Repeat("a", 10000), 10000),
		},
		{
			name:     "Non-English string, positive integer",
			input:    "你好",
			repeat:   2,
			expected: "你好你好",
		},
		{
			name:     "String with newline characters, positive integer",
			input:    "abc\ndef",
			repeat:   2,
			expected: "abc\ndefabc\ndef",
		},
		{
			name:     "String with escape sequences, positive integer",
			input:    "abc\\ndef",
			repeat:   2,
			expected: "abc\\ndefabc\\ndef",
		},
	}

	for _, tc := range testCases {
		t.Run(tc.name, func(t *testing.T) {
			funcMap := make(template.FuncMap)
			Repeat()(funcMap)
			if tc.repeat < 0 {
				defer func() {
					if r := recover(); r == nil {
						t.Errorf("Repeat(%q, %d) should panic for negative repeat", tc.input, tc.repeat)
					}
				}()
			}
			actual := funcMap["repeat"].(func(string, int) string)(tc.input, tc.repeat)
			if actual != tc.expected {
				t.Errorf("Repeat(%q, %d) = %q; expected %q", tc.input, tc.repeat, actual, tc.expected)
			}
		})
	}
}
